import cv2
import numpy as np
from picamera2 import Picamera2

# ================== USER SETTINGS ==================

# Real side length of your ArUco marker in millimeters.
# If your printed marker is not 60 mm, CHANGE this value.
MARKER_LENGTH_MM = 60.0

# ArUco dictionary used for your marker IDs
ARUCO_DICT_TYPE = cv2.aruco.DICT_4X4_50

# Calibration file generated by calibrate_charuco_a2.py
CALIB_FILE = "charuco_a2_camera_params.npz"

# ===================================================


# ---------- LOAD CAMERA CALIBRATION ----------
data = np.load(CALIB_FILE)
camera_matrix = data["camera_matrix"]
dist_coeffs = data["dist_coeffs"]
img_width = int(data["img_width"])
img_height = int(data["img_height"])

print("Loaded A2 Charuco calibration:")
print("camera_matrix:\n", camera_matrix)
print("dist_coeffs:\n", dist_coeffs)
print(f"Calibrated resolution: {img_width} x {img_height}")

# ---------- ARUCO SETUP ----------
dictionary = cv2.aruco.getPredefinedDictionary(ARUCO_DICT_TYPE)
detector_params = cv2.aruco.DetectorParameters_create()

# ---------- CAMERA SETUP ----------
FRAME_SIZE = (img_width, img_height)  # must match calibration resolution

picam2 = Picamera2()
config = picam2.create_preview_configuration(
    main={"format": "RGB888", "size": FRAME_SIZE}
)
picam2.configure(config)
picam2.start()

print("\n--- ArUco Distance Measurement (Calibrated with A2 Charuco) ---")
print("Press 'q' in the window to quit.\n")

while True:
    # Capture frame
    frame = picam2.capture_array()
    gray = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)

    # Detect ArUco markers
    corners, ids, rejected = cv2.aruco.detectMarkers(
        gray, dictionary, parameters=detector_params
    )

    if ids is not None and len(ids) > 0:
        # Draw detected markers
        cv2.aruco.drawDetectedMarkers(frame, corners, ids)

        # Estimate pose of each marker
        rvecs, tvecs, _ = cv2.aruco.estimatePoseSingleMarkers(
            corners, MARKER_LENGTH_MM, camera_matrix, dist_coeffs
        )

        for i, marker_id in enumerate(ids.flatten()):
            rvec = rvecs[i, 0, :]  # rotation vector
            tvec = tvecs[i, 0, :]  # translation vector [tx, ty, tz] in mm

            x_mm, y_mm, z_mm = map(float, tvec)

            # -------- DISTANCE CALCULATIONS --------
            # Full 3D distance from camera center to marker center
            distance_mm = float(np.linalg.norm(tvec))
            distance_cm = distance_mm / 10.0

            # z_mm is the straight-line depth along the camera's optical axis
            # (this is usually what you think of as "distance in front of camera")

            # -------- OPTIONAL: VIEW & TILT ANGLES --------
            # Viewing angle: angle between camera forward axis (Z) and line to marker center
            if distance_mm > 1e-6:
                view_angle_deg = float(
                    np.degrees(np.arccos(z_mm / distance_mm))
                )
            else:
                view_angle_deg = 0.0

            # Marker plane tilt: how much the marker surface is tilted w.r.t. camera
            R, _ = cv2.Rodrigues(rvec)
            marker_normal = R[:, 2]   # local Z axis of marker in camera coords
            nz = float(marker_normal[2])
            nz = max(min(nz, 1.0), -1.0)
            tilt_angle_deg = float(np.degrees(np.arccos(nz)))

            # -------- DRAW AXES (for visualization) --------
            cv2.aruco.drawAxis(
                frame, camera_matrix, dist_coeffs,
                rvec, tvec, MARKER_LENGTH_MM * 0.5
            )

            # -------- DISPLAY TEXT NEAR MARKER --------
            c = corners[i][0]
            center_x = int(c[:, 0].mean())
            center_y = int(c[:, 1].mean())

            dy = 22

            line1 = f"ID {marker_id}"
            line2 = f"Dist3D: {distance_mm:.2f} mm ({distance_cm:.2f} cm)"
            line3 = f"Depth Z: {z_mm:.2f} mm"
            line4 = f"X: {x_mm:.2f} mm  Y: {y_mm:.2f} mm"
            line5 = f"View angle: {view_angle_deg:.1f} deg"
            line6 = f"Tilt angle: {tilt_angle_deg:.1f} deg"

            cv2.putText(frame, line1, (center_x - 140, center_y - 3*dy),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 0), 2)
            cv2.putText(frame, line2, (center_x - 140, center_y - 2*dy),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
            cv2.putText(frame, line3, (center_x - 140, center_y - 1*dy),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 0), 1)
            cv2.putText(frame, line4, (center_x - 140, center_y),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 255), 1)
            cv2.putText(frame, line5, (center_x - 140, center_y + 1*dy),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 200, 255), 1)
            cv2.putText(frame, line6, (center_x - 140, center_y + 2*dy),
                        cv2.FONT_HERSHEY_SIMPLEX, 0.5, (200, 200, 0), 1)

    cv2.imshow("ArUco Distance (A2 Charuco calibrated)", frame)

    key = cv2.waitKey(1) & 0xFF
    if key == ord('q'):
        break

cv2.destroyAllWindows()
picam2.stop()
